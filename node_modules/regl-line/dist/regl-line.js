(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('gl-matrix')) :
  typeof define === 'function' && define.amd ? define(['gl-matrix'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.createLine = factory(global.glMatrix));
}(this, (function (glMatrix) { 'use strict';

  var FRAGMENT_SHADER = "\nprecision mediump float;\nvarying vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}";

  // Vertex shader from https://mattdesl.svbtle.com/drawing-lines-is-hard
  // The MIT License (MIT) Copyright (c) 2015 Matt DesLauriers
  var VERTEX_SHADER = "\nuniform mat4 projectionViewModel;\nuniform float aspectRatio;\n\nuniform sampler2D colorTex;\nuniform float colorTexRes;\nuniform float colorTexEps;\nuniform float width;\nuniform float useOpacity;\nuniform float useColorOpacity;\nuniform int miter;\n\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\nattribute float opacity;\nattribute float offsetScale;\nattribute float colorIndex;\n\nvarying vec4 color;\n\nvoid main() {\n  vec2 aspectVec = vec2(aspectRatio, 1.0);\n  vec4 prevProjected = projectionViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projectionViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projectionViewModel * vec4(nextPosition, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected.xy / prevProjected.w * aspectVec;\n  vec2 currScreen = currProjected.xy / currProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n\n  // starting point uses (next - current)\n  vec2 dir = vec2(0.0);\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (miter == 1) {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n    } else {\n      dir = dirA;\n    }\n  }\n\n  vec2 normal = vec2(-dir.y, dir.x) * width;\n  normal.x /= aspectRatio;\n  vec4 offset = vec4(normal * offsetScale, 0.0, 0.0);\n  gl_Position = currProjected + offset;\n\n  // Get color from texture\n  float colorRowIndex = floor((colorIndex + colorTexEps) / colorTexRes);\n  vec2 colorTexIndex = vec2(\n    (colorIndex / colorTexRes) - colorRowIndex + colorTexEps,\n    colorRowIndex / colorTexRes + colorTexEps\n  );\n\n  color = texture2D(colorTex, colorTexIndex);\n  color.a = useColorOpacity * color.a + useOpacity * opacity;\n}";

  var ref = Array.prototype;
  var push = ref.push;
  var splice = ref.splice;

  var I = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var FLOAT_BYTES = Float32Array.BYTES_PER_ELEMENT;

  var createMesh = function (numPointsPerLine, buffer) {
    if ( buffer === void 0 ) buffer = [];

    var numPrevPoints = 0;
    numPointsPerLine.forEach(function (numPoints) {
      for (var i = 0; i < numPoints - 1; i++) {
        var a = numPrevPoints + i * 2; // `2`  because we duplicated all points
        var b = a + 1;
        var c = a + 2;
        var d = a + 3;
        buffer.push(a, b, c, c, b, d);
      }
      // Each line adds an additional start and end point, hence, `numPoints + 2`
      // And again, since all points are duplicated, we have `* 2`
      numPrevPoints += (numPoints + 2) * 2;
    });
    return buffer;
  };

  var Buffer = {
    duplicate: function duplicate(buffer, stride, dupScale) {
      if ( stride === void 0 ) stride = 1;
      if ( dupScale === void 0 ) dupScale = 1;

      var out = [];
      var component = new Array(stride * 2);
      for (var i = 0, il = buffer.length / stride; i < il; i++) {
        var index = i * stride;
        for (var j = 0; j < stride; j++) {
          var value = buffer[index + j];
          component[j] = value;
          component[j + stride] = value * dupScale;
        }
        push.apply(out, component);
      }
      return out;
    },

    mapElement: function mapElement(buffer, elementIndex, stride, map) {
      for (var i = 0, il = buffer.length / stride; i < il; i++) {
        var index = elementIndex + i * stride;
        buffer[index] = map(buffer[index], index, i);
      }
      return buffer;
    },

    copyElement: function copyElement(buffer, sourceElementIndex, targetIndex, stride) {
      var component = new Array(stride);
      var ai = sourceElementIndex * stride;
      // Copy source element component wise
      for (var i = 0; i < stride; i++) { component[i] = buffer[ai + i]; }
      splice.call.apply(splice, [ buffer, targetIndex * stride, 0 ].concat( component ));
      return buffer;
    },

    increaseStride: function increaseStride(buffer, stride, newStride, undefValue) {
      if ( undefValue === void 0 ) undefValue = 0;

      var out = [];
      var component = new Array(newStride).fill(undefValue);
      for (var i = 0, il = buffer.length / stride; i < il; i++) {
        var index = i * stride;
        for (var j = 0; j < stride; j++) {
          component[j] = buffer[index + j];
        }
        push.apply(out, component);
      }
      return out;
    },
  };

  var createLine = function (
    regl,
    ref
  ) {
    if ( ref === void 0 ) ref = {};
    var projection = ref.projection; if ( projection === void 0 ) projection = I;
    var model = ref.model; if ( model === void 0 ) model = I;
    var view = ref.view; if ( view === void 0 ) view = I;
    var points = ref.points; if ( points === void 0 ) points = [];
    var colorIndices = ref.colorIndices; if ( colorIndices === void 0 ) colorIndices = [];
    var color = ref.color; if ( color === void 0 ) color = [0.8, 0.5, 0, 1];
    var opacity = ref.opacity; if ( opacity === void 0 ) opacity = null;
    var opacities = ref.opacities; if ( opacities === void 0 ) opacities = [];
    var width = ref.width; if ( width === void 0 ) width = 1;
    var widths = ref.widths; if ( widths === void 0 ) widths = [];
    var miter = ref.miter; if ( miter === void 0 ) miter = 1;
    var is2d = ref.is2d; if ( is2d === void 0 ) is2d = false;
    var zPos2d = ref.zPos2d; if ( zPos2d === void 0 ) zPos2d = 0;

    if (!regl) {
      console.error('Regl instance is undefined.');
      return;
    }

    var pvm = new Float32Array(16);

    var numLines;
    var numPoints;
    var numPointsPerLine;
    var pointsPadded;
    var pointsDup;
    var colorIndicesDup;
    var opacitiesDup;
    var widthsDup;
    var indices;
    var pointBuffer;
    var opacityBuffer;
    var widthBuffer;
    var colorTex;
    var colorTexRes;
    var colorIndexBuffer;
    var attributes;
    var elements;
    var drawLine;
    var dim = is2d ? 2 : 3;

    var useOpacity = function () { return +(opacities.length === numPoints || opacity !== null); };

    var init = function () {
      pointBuffer = regl.buffer();
      opacityBuffer = regl.buffer();
      widthBuffer = regl.buffer();
      colorIndexBuffer = regl.buffer();

      attributes = {
        prevPosition: {
          buffer: function () { return pointBuffer; },
          offset: 0,
          stride: FLOAT_BYTES * 3,
        },
        currPosition: {
          buffer: function () { return pointBuffer; },
          // note that each point is duplicated, hence we need to skip over the first two
          offset: FLOAT_BYTES * 3 * 2,
          stride: FLOAT_BYTES * 3,
        },
        nextPosition: {
          buffer: function () { return pointBuffer; },
          // note that each point is duplicated, hence we need to skip over the first four
          offset: FLOAT_BYTES * 3 * 4,
          stride: FLOAT_BYTES * 3,
        },
        opacity: {
          buffer: function () { return opacityBuffer; },
          // note that each point is duplicated, hence we need to skip over the first two
          offset: FLOAT_BYTES * 2,
          stride: FLOAT_BYTES,
        },
        offsetScale: {
          buffer: function () { return widthBuffer; },
          // note that each point is duplicated, hence we need to skip over the first two
          offset: FLOAT_BYTES * 2,
          stride: FLOAT_BYTES,
        },
        colorIndex: {
          buffer: function () { return colorIndexBuffer; },
          // note that each point is duplicated, hence we need to skip over the first two
          offset: FLOAT_BYTES * 2,
          stride: FLOAT_BYTES,
        },
      };

      elements = regl.elements();

      drawLine = regl({
        attributes: attributes,
        depth: { enable: !is2d },
        blend: {
          enable: true,
          func: {
            srcRGB: 'src alpha',
            srcAlpha: 'one',
            dstRGB: 'one minus src alpha',
            dstAlpha: 'one minus src alpha',
          },
        },
        uniforms: {
          projectionViewModel: function (context, props) {
            var projection = context.projection || props.projection;
            var model = context.model || props.model;
            var view = context.view || props.view;
            return glMatrix.mat4.multiply(
              pvm,
              projection,
              glMatrix.mat4.multiply(pvm, view, model)
            );
          },
          aspectRatio: function (ref) {
              var viewportWidth = ref.viewportWidth;
              var viewportHeight = ref.viewportHeight;

              return viewportWidth / viewportHeight;
      },
          colorTex: function () { return colorTex; },
          colorTexRes: function () { return colorTexRes; },
          colorTexEps: function () { return 0.5 / colorTexRes; },
          pixelRatio: function (ref) {
            var pixelRatio = ref.pixelRatio;

            return pixelRatio;
      },
          width: function (ref) {
              var pixelRatio = ref.pixelRatio;
              var viewportHeight = ref.viewportHeight;

              return (width / viewportHeight) * pixelRatio;
      },
          useOpacity: useOpacity,
          useColorOpacity: function () { return +!useOpacity(); },
          miter: miter,
        },
        elements: function () { return elements; },
        vert: VERTEX_SHADER,
        frag: FRAGMENT_SHADER,
      });
    };

    var prepare = function () {
      if (numLines === 1 && points.length % dim > 0) {
        console.warn(
          ("The length of points (" + numPoints + ") does not match the dimensions (" + dim + "). Incomplete points are ignored.")
        );
      }

      // Copy all points belonging to complete points
      pointsPadded = points.flat().slice(0, numPoints * dim);

      // Add the missing z point
      if (is2d) {
        pointsPadded = Buffer.increaseStride(pointsPadded, 2, 3, zPos2d);
      }

      if (colorIndices.length !== numPoints)
        { colorIndices = new Array(numPoints).fill(0); }

      if (widths.length !== numPoints) { widths = new Array(numPoints).fill(1); }

      var finalColorIndices = colorIndices.slice();
      var finalOpacities =
        opacities.length === numPoints
          ? opacities.slice()
          : new Array(numPoints).fill(+opacity);
      var finalWidths = widths.slice();

      var k = 0;
      numPointsPerLine.forEach(function (n) {
        var lastPointIdx = k + n - 1;
        // For each line, duplicate the first and last point.
        // E.g., [1,2,3] -> [1,1,2,3,3]
        // First, copy the last point to the end
        Buffer.copyElement(pointsPadded, lastPointIdx, lastPointIdx, 3);
        // Second, copy the first point to the beginning
        Buffer.copyElement(pointsPadded, k, k, 3);

        Buffer.copyElement(finalColorIndices, lastPointIdx, lastPointIdx, 1);
        Buffer.copyElement(finalColorIndices, k, k, 1);
        Buffer.copyElement(finalOpacities, lastPointIdx, lastPointIdx, 1);
        Buffer.copyElement(finalOpacities, k, k, 1);
        Buffer.copyElement(finalWidths, lastPointIdx, lastPointIdx, 1);
        Buffer.copyElement(finalWidths, k, k, 1);

        k += n + 2;
      });

      // duplicate each point for the positive and negative width (see below)
      pointsDup = new Float32Array(Buffer.duplicate(pointsPadded, 3));
      // duplicate each color, opacity, and width such that we have a positive
      // and negative width
      colorIndicesDup = Buffer.duplicate(finalColorIndices);
      opacitiesDup = Buffer.duplicate(finalOpacities);
      widthsDup = Buffer.duplicate(finalWidths, 1, -1);
      // create the line mesh, i.e., the vertex indices
      indices = createMesh(numPointsPerLine);

      pointBuffer({
        usage: 'dynamic',
        type: 'float',
        length: pointsDup.length * FLOAT_BYTES,
        data: pointsDup,
      });

      opacityBuffer({
        usage: 'dynamic',
        type: 'float',
        length: opacitiesDup.length * FLOAT_BYTES,
        data: opacitiesDup,
      });

      widthBuffer({
        usage: 'dynamic',
        type: 'float',
        length: widthsDup.length * FLOAT_BYTES,
        data: widthsDup,
      });

      colorIndexBuffer({
        usage: 'dynamic',
        type: 'float',
        length: colorIndicesDup.length * FLOAT_BYTES,
        data: colorIndicesDup,
      });

      elements({
        primitive: 'triangles',
        usage: 'dynamic',
        type: indices.length > Math.pow( 2, 16 ) ? 'uint32' : 'uint16',
        data: indices,
      });
    };

    var clear = function () {
      destroy();
      init();
    };

    var destroy = function () {
      points = null;
      pointsPadded = null;
      pointsDup = null;
      widthsDup = null;
      indices = null;
      pointBuffer.destroy();
      widthBuffer.destroy();
      elements.destroy();
    };

    var draw = function (ref) {
      if ( ref === void 0 ) ref = {};
      var newProjection = ref.projection;
      var newModel = ref.model;
      var newView = ref.view;

      // cache the view-defining matrices
      if (newProjection) {
        projection = newProjection;
      }
      if (newModel) {
        model = newModel;
      }
      if (newView) {
        view = newView;
      }
      // only draw when some points have been specified
      if (points && points.length > 1) {
        drawLine({ projection: projection, model: model, view: view });
      }
    };

    var getPerPointProperty = function (property, newValues) {
      var flatNewValues = newValues.flat(2);

      if (flatNewValues.length === numPoints) {
        return flatNewValues;
      } else if (flatNewValues.length === numLines) {
        return numPointsPerLine
          .map(function (n, i) { return Array(n).fill(flatNewValues[i]); })
          .flat();
      }

      return property;
    };

    var getPoints = function () { return points; };

    var setPoints = function (
      newPoints,
      ref
    ) {
      if ( newPoints === void 0 ) newPoints = [];
      if ( ref === void 0 ) ref = {};
      var newColorIndices = ref.colorIndices; if ( newColorIndices === void 0 ) newColorIndices = colorIndices;
      var newOpacities = ref.opacities; if ( newOpacities === void 0 ) newOpacities = opacities;
      var newWidths = ref.widths; if ( newWidths === void 0 ) newWidths = widths;
      var newIs2d = ref.is2d; if ( newIs2d === void 0 ) newIs2d = is2d;

      points = newPoints;
      is2d = newIs2d;
      dim = is2d ? 2 : 3;

      numLines = Array.isArray(points[0]) ? points.length : 1;
      numPointsPerLine =
        numLines > 1
          ? points.map(function (pts) { return Math.floor(pts.length / dim); })
          : [Math.floor(points.length / dim)];
      numPoints = numPointsPerLine.reduce(function (n, nPts) { return n + nPts; }, 0);

      colorIndices = getPerPointProperty(colorIndices, newColorIndices);
      opacities = getPerPointProperty(opacities, newOpacities);
      widths = getPerPointProperty(widths, newWidths);

      if (points && numPoints > 1) {
        prepare();
      } else {
        clear();
      }
    };

    var getNestedness = function (arr, level) {
      if ( level === void 0 ) level = -1;

      if (!Array.isArray(arr)) { return level; }
      if (arr.length && !Array.isArray(arr[0])) { return level + 1; }
      return getNestedness(arr[0], ++level);
    };

    var createColorTexture = function () {
      var colors = getNestedness(color) === 0 ? [color] : color;

      colorTexRes = Math.max(2, Math.ceil(Math.sqrt(colors.length)));
      var rgba = new Uint8Array(Math.pow( colorTexRes, 2 ) * 4);

      colors.forEach(function (color, i) {
        rgba[i * 4] = Math.min(255, Math.max(0, Math.round(color[0] * 255))); // r
        rgba[i * 4 + 1] = Math.min(255, Math.max(0, Math.round(color[1] * 255))); // g
        rgba[i * 4 + 2] = Math.min(255, Math.max(0, Math.round(color[2] * 255))); // b
        rgba[i * 4 + 3] = Number.isNaN(+color[3])
          ? 255
          : Math.min(255, Math.max(0, Math.round(color[3] * 255))); // a
      });

      colorTex = regl.texture({
        data: rgba,
        shape: [colorTexRes, colorTexRes, 4],
      });
    };

    var setColor = function (newColor, newOpacity) {
      if ( newOpacity === void 0 ) newOpacity = opacity;

      color = newColor;
      opacity = newOpacity;
      if (colorTex) { colorTex.destroy(); }
      createColorTexture();
    };

    var getStyle = function () { return ({ color: color, miter: miter, width: width }); };

    var setStyle = function (ref) {
      if ( ref === void 0 ) ref = {};
      var newColor = ref.color;
      var newOpacity = ref.opacity;
      var newMiter = ref.miter;
      var newWidth = ref.width;

      if (newColor) { setColor(newColor, newOpacity); }
      if (newMiter) { miter = newMiter; }
      if (+newWidth > 0) { width = newWidth; }
    };

    var getBuffer = function () { return ({
      points: pointBuffer,
      widths: widthBuffer,
      opacities: opacityBuffer,
      colorIndices: colorIndexBuffer,
    }); };

    var getData = function () { return ({
      points: pointsDup,
      widths: widthsDup,
      opacities: opacitiesDup,
      colorIndices: colorIndicesDup,
    }); };

    // initialize parameters
    init();
    createColorTexture();

    // prepare data if points are already specified
    if (points && points.length > 1) {
      setPoints(points);
    }

    return {
      clear: clear,
      destroy: destroy,
      draw: draw,
      getPoints: getPoints,
      setPoints: setPoints,
      getData: getData,
      getBuffer: getBuffer,
      getStyle: getStyle,
      setStyle: setStyle,
    };
  };

  return createLine;

})));
