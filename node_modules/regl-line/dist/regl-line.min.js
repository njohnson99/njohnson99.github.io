!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n(require("gl-matrix")):"function"==typeof define&&define.amd?define(["gl-matrix"],n):(e="undefined"!=typeof globalThis?globalThis:e||self).createLine=n(e.glMatrix)}(this,(function(e){"use strict";var n=Array.prototype,r=n.push,t=n.splice,o=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),i=Float32Array.BYTES_PER_ELEMENT,c=function(e,n,t){void 0===n&&(n=1),void 0===t&&(t=1);for(var o=[],i=new Array(2*n),c=0,a=e.length/n;c<a;c++){for(var l=c*n,u=0;u<n;u++){var f=e[l+u];i[u]=f,i[u+n]=f*t}r.apply(o,i)}return o},a=function(e,n,r,o){for(var i=new Array(o),c=n*o,a=0;a<o;a++)i[a]=e[c+a];return t.call.apply(t,[e,r*o,0].concat(i)),e},l=function(e,n,t,o){void 0===o&&(o=0);for(var i=[],c=new Array(t).fill(o),a=0,l=e.length/n;a<l;a++){for(var u=a*n,f=0;f<n;f++)c[f]=e[u+f];r.apply(i,c)}return i};return function(n,r){void 0===r&&(r={});var t=r.projection;void 0===t&&(t=o);var u=r.model;void 0===u&&(u=o);var f=r.view;void 0===f&&(f=o);var d=r.points;void 0===d&&(d=[]);var s=r.colorIndices;void 0===s&&(s=[]);var v=r.color;void 0===v&&(v=[.8,.5,0,1]);var p=r.opacity;void 0===p&&(p=null);var h=r.opacities;void 0===h&&(h=[]);var m=r.width;void 0===m&&(m=1);var y=r.widths;void 0===y&&(y=[]);var g=r.miter;void 0===g&&(g=1);var x=r.is2d;void 0===x&&(x=!1);var w=r.zPos2d;if(void 0===w&&(w=0),n){var A,M,b,P,j,S,T,R,I,E,V,B,z,O,C,F,D,N,_=new Float32Array(16),G=x?2:3,q=function(){return+(h.length===M||null!==p)},H=function(){E=n.buffer(),V=n.buffer(),B=n.buffer(),C=n.buffer(),F={prevPosition:{buffer:function(){return E},offset:0,stride:3*i},currPosition:{buffer:function(){return E},offset:3*i*2,stride:3*i},nextPosition:{buffer:function(){return E},offset:3*i*4,stride:3*i},opacity:{buffer:function(){return V},offset:2*i,stride:i},offsetScale:{buffer:function(){return B},offset:2*i,stride:i},colorIndex:{buffer:function(){return C},offset:2*i,stride:i}},D=n.elements(),N=n({attributes:F,depth:{enable:!x},blend:{enable:!0,func:{srcRGB:"src alpha",srcAlpha:"one",dstRGB:"one minus src alpha",dstAlpha:"one minus src alpha"}},uniforms:{projectionViewModel:function(n,r){var t=n.projection||r.projection,o=n.model||r.model,i=n.view||r.view;return e.mat4.multiply(_,t,e.mat4.multiply(_,i,o))},aspectRatio:function(e){return e.viewportWidth/e.viewportHeight},colorTex:function(){return z},colorTexRes:function(){return O},colorTexEps:function(){return.5/O},pixelRatio:function(e){return e.pixelRatio},width:function(e){var n=e.pixelRatio,r=e.viewportHeight;return m/r*n},useOpacity:q,useColorOpacity:function(){return+!q()},miter:g},elements:function(){return D},vert:"\nuniform mat4 projectionViewModel;\nuniform float aspectRatio;\n\nuniform sampler2D colorTex;\nuniform float colorTexRes;\nuniform float colorTexEps;\nuniform float width;\nuniform float useOpacity;\nuniform float useColorOpacity;\nuniform int miter;\n\nattribute vec3 prevPosition;\nattribute vec3 currPosition;\nattribute vec3 nextPosition;\nattribute float opacity;\nattribute float offsetScale;\nattribute float colorIndex;\n\nvarying vec4 color;\n\nvoid main() {\n  vec2 aspectVec = vec2(aspectRatio, 1.0);\n  vec4 prevProjected = projectionViewModel * vec4(prevPosition, 1.0);\n  vec4 currProjected = projectionViewModel * vec4(currPosition, 1.0);\n  vec4 nextProjected = projectionViewModel * vec4(nextPosition, 1.0);\n\n  // get 2D screen space with W divide and aspect correction\n  vec2 prevScreen = prevProjected.xy / prevProjected.w * aspectVec;\n  vec2 currScreen = currProjected.xy / currProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n\n  // starting point uses (next - current)\n  vec2 dir = vec2(0.0);\n  if (currScreen == prevScreen) {\n    dir = normalize(nextScreen - currScreen);\n  }\n  // ending point uses (current - previous)\n  else if (currScreen == nextScreen) {\n    dir = normalize(currScreen - prevScreen);\n  }\n  // somewhere in middle, needs a join\n  else {\n    // get directions from (C - B) and (B - A)\n    vec2 dirA = normalize((currScreen - prevScreen));\n    if (miter == 1) {\n      vec2 dirB = normalize((nextScreen - currScreen));\n      // now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      dir = tangent;\n    } else {\n      dir = dirA;\n    }\n  }\n\n  vec2 normal = vec2(-dir.y, dir.x) * width;\n  normal.x /= aspectRatio;\n  vec4 offset = vec4(normal * offsetScale, 0.0, 0.0);\n  gl_Position = currProjected + offset;\n\n  // Get color from texture\n  float colorRowIndex = floor((colorIndex + colorTexEps) / colorTexRes);\n  vec2 colorTexIndex = vec2(\n    (colorIndex / colorTexRes) - colorRowIndex + colorTexEps,\n    colorRowIndex / colorTexRes + colorTexEps\n  );\n\n  color = texture2D(colorTex, colorTexIndex);\n  color.a = useColorOpacity * color.a + useOpacity * opacity;\n}",frag:"\nprecision mediump float;\nvarying vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}"})},L=function(){W(),H()},W=function(){d=null,P=null,j=null,R=null,I=null,E.destroy(),B.destroy(),D.destroy()},U=function(e,n){var r=n.flat(2);return r.length===M?r:r.length===A?b.map((function(e,n){return Array(e).fill(r[n])})).flat():e},Y=function(e,n){void 0===e&&(e=[]),void 0===n&&(n={});var r=n.colorIndices;void 0===r&&(r=s);var t=n.opacities;void 0===t&&(t=h);var o=n.widths;void 0===o&&(o=y);var u=n.is2d;void 0===u&&(u=x),d=e,G=(x=u)?2:3,A=Array.isArray(d[0])?d.length:1,b=A>1?d.map((function(e){return Math.floor(e.length/G)})):[Math.floor(d.length/G)],M=b.reduce((function(e,n){return e+n}),0),s=U(s,r),h=U(h,t),y=U(y,o),d&&M>1?function(){1===A&&d.length%G>0&&console.warn("The length of points ("+M+") does not match the dimensions ("+G+"). Incomplete points are ignored."),P=d.flat().slice(0,M*G),x&&(P=l(P,2,3,w)),s.length!==M&&(s=new Array(M).fill(0)),y.length!==M&&(y=new Array(M).fill(1));var e=s.slice(),n=h.length===M?h.slice():new Array(M).fill(+p),r=y.slice(),t=0;b.forEach((function(o){var i=t+o-1;a(P,i,i,3),a(P,t,t,3),a(e,i,i,1),a(e,t,t,1),a(n,i,i,1),a(n,t,t,1),a(r,i,i,1),a(r,t,t,1),t+=o+2})),j=new Float32Array(c(P,3)),S=c(e),T=c(n),R=c(r,1,-1),I=function(e,n){void 0===n&&(n=[]);var r=0;return e.forEach((function(e){for(var t=0;t<e-1;t++){var o=r+2*t,i=o+1,c=o+2,a=o+3;n.push(o,i,c,c,i,a)}r+=2*(e+2)})),n}(b),E({usage:"dynamic",type:"float",length:j.length*i,data:j}),V({usage:"dynamic",type:"float",length:T.length*i,data:T}),B({usage:"dynamic",type:"float",length:R.length*i,data:R}),C({usage:"dynamic",type:"float",length:S.length*i,data:S}),D({primitive:"triangles",usage:"dynamic",type:I.length>Math.pow(2,16)?"uint32":"uint16",data:I})}():L()},k=function(e,n){return void 0===n&&(n=-1),Array.isArray(e)?e.length&&!Array.isArray(e[0])?n+1:k(e[0],++n):n},J=function(){var e=0===k(v)?[v]:v;O=Math.max(2,Math.ceil(Math.sqrt(e.length)));var r=new Uint8Array(4*Math.pow(O,2));e.forEach((function(e,n){r[4*n]=Math.min(255,Math.max(0,Math.round(255*e[0]))),r[4*n+1]=Math.min(255,Math.max(0,Math.round(255*e[1]))),r[4*n+2]=Math.min(255,Math.max(0,Math.round(255*e[2]))),r[4*n+3]=Number.isNaN(+e[3])?255:Math.min(255,Math.max(0,Math.round(255*e[3])))})),z=n.texture({data:r,shape:[O,O,4]})};return H(),J(),d&&d.length>1&&Y(d),{clear:L,destroy:W,draw:function(e){void 0===e&&(e={});var n=e.projection,r=e.model,o=e.view;n&&(t=n),r&&(u=r),o&&(f=o),d&&d.length>1&&N({projection:t,model:u,view:f})},getPoints:function(){return d},setPoints:Y,getData:function(){return{points:j,widths:R,opacities:T,colorIndices:S}},getBuffer:function(){return{points:E,widths:B,opacities:V,colorIndices:C}},getStyle:function(){return{color:v,miter:g,width:m}},setStyle:function(e){void 0===e&&(e={});var n=e.color,r=e.opacity,t=e.miter,o=e.width;n&&function(e,n){void 0===n&&(n=p),v=e,p=n,z&&z.destroy(),J()}(n,r),t&&(g=t),+o>0&&(m=o)}}}console.error("Regl instance is undefined.")}}));
