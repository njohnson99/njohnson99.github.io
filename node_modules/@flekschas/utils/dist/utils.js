// @flekschas/utils v0.29.0 Copyright 2021 Fritz Lekschas
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/toConsumableArray'), require('@babel/runtime/helpers/defineEnumerableProperties'), require('@babel/runtime/helpers/defineProperty'), require('@babel/runtime/helpers/typeof'), require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/regenerator')) :
  typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/toConsumableArray', '@babel/runtime/helpers/defineEnumerableProperties', '@babel/runtime/helpers/defineProperty', '@babel/runtime/helpers/typeof', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/regenerator'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.utils = {}, global._toConsumableArray, global._defineEnumerableProperties, global._defineProperty, global._typeof, global._slicedToArray, global._regeneratorRuntime));
}(this, (function (exports, _toConsumableArray, _defineEnumerableProperties, _defineProperty, _typeof, _slicedToArray, _regeneratorRuntime) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
  var _defineEnumerableProperties__default = /*#__PURE__*/_interopDefaultLegacy(_defineEnumerableProperties);
  var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
  var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
  var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
  var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);

  /* eslint no-param-reassign:0 */

  /**
   * Cubic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */
  var cubicIn = function cubicIn(t) {
    return t * t * t;
  };
  /**
   * Cubic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var cubicInOut = function cubicInOut(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  };
  /**
   * Cubic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var cubicOut = function cubicOut(t) {
    return --t * t * t + 1;
  };
  /**
   * Linearly interpolate two numbers
   * @param {number} a - The start value
   * @param {number} b - The end value
   * @param {number} p - The interpolation progress. Must be in [0, 1] where `0`
   *   refers to the start value and `1` to the end value
   * @return {number} The interpolated number
   */

  var interpolateNumber = function interpolateNumber(a, b, p) {
    // eslint-disable-next-line no-param-reassign
    p = Math.min(1, Math.max(0, p));
    return a * (1 - p) + b * p;
  };
  /**
   * Lineraly interpolate a numerical vector
   * @param {array} a - The start vector
   * @param {array} b - The end vector
   * @param {number} p - The interpolation progress. Must be in [0, 1] where `0`
   *   refers to the start vector and `1` to the end vector
   * @return {array} The interpolated vector
   */

  var interpolateVector = function interpolateVector(a, b, p) {
    return a.map(function (x, i) {
      return interpolateNumber(x, b[i], p);
    });
  };
  /**
   * Linear easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} Same as the input
   */

  var linear = function linear(t) {
    return t;
  };
  /**
   * Quadratic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quadIn = function quadIn(t) {
    return t * t;
  };
  /**
   * Quadratic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quadInOut = function quadInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  };
  /**
   * Quadratic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quadOut = function quadOut(t) {
    return t * (2 - t);
  };
  /**
   * Quartic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quartIn = function quartIn(t) {
    return t * t * t * t;
  };
  /**
   * Quartic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quartOut = function quartOut(t) {
    return 1 - --t * t * t * t;
  };
  /**
   * Quartic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quartInOut = function quartInOut(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  };
  /**
   * Quintic in easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quintIn = function quintIn(t) {
    return t * t * t * t * t;
  };
  /**
   * Quintic in and out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quintOut = function quintOut(t) {
    return 1 + --t * t * t * t * t;
  };
  /**
   * Quintic out easing function
   * @param {number} t - The input time to be eased. Must be in [0, 1] where `0`
   *   refers to the start and `1` to the end
   * @return {number} The eased time
   */

  var quintInOut = function quintInOut(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  };

  /**
   * Restrict value to be within [min, max]
   * @description About 18% faster than `Math.max(min, Math.min(max, value))`
   * @param {Number} value - Value to be clamped
   * @param {Number} min - Min value
   * @param {Number} max - Max value
   * @return {Number} Clamped value
   */
  var clamp = function clamp(value, min, max) {
    return (// eslint-disable-next-line no-nested-ternary
      value < min ? min : value > max ? max : value
    );
  };
  /**
   * Identity function
   * @param   {*}  x  Any kind of value
   * @return  {*}  `x`
   */

  var identity = function identity(x) {
    return x;
  };
  /**
   * Test if two floats are close given some precision
   * @param {number} a - First float
   * @param {number} b - Second float
   * @param {number} precision - Number of decimal places to check
   * @return {boolean} If `true` the difference between the floats is less than
   *   10^-precision
   */

  var isClose = function isClose(a, b) {
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 6;
    return Math.abs(a - b) < Math.pow(10, -precision);
  };

  /**
   * Transpose a nested 2D array
   * @param {array} matrix - The matrix-liked 2D nested array to be transposed
   * @return {array} The transposed 2D nested matrix-like array
   */

  var array2dTranspose = function array2dTranspose(matrix) {
    // Create a nested 2D array with transposed shape
    var out = _toConsumableArray__default['default'](new Array(matrix[0].length).fill().map(function () {
      return [];
    })); // Fill the transposed array


    for (var i = 0; i < matrix.length; i++) {
      for (var j = 0; j < matrix[i].length; j++) {
        out[j][i] = matrix[i][j];
      }
    }

    return out;
  };
  /**
   * Clear an array without while keeping it's reference
   * @param {array} a - Array to be cleared
   * @return {array} The array itself
   */

  var clearArray = function clearArray(a) {
    a.splice(0, a.length);
    return a;
  };
  /**
   * Return unique values of an array
   * @param {array} a - Input array
   * @return {array} Array with unique values
   */

  var unique = function unique(a) {
    var getter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
    var s = new Set();
    var out = [];

    for (var i = 0; i < a.length; i++) {
      var v = getter(a[i]);

      if (!s.has(v)) {
        s.add(v);
        out.push(v);
      }
    }

    return out;
  };

  /**
   * Test if a variable is an array
   * @param {*} f - The variable to test
   * @return {boolean} If `true` the variable is an array.
   */
  var isArray = Array.isArray;
  /**
   * Test if a variable is a function
   * @param {*} f - The variable to test
   * @return {boolean} If `true` the variable is a function.
   */

  var isFunction = function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
  };
  /**
   * Tests if a string is a valid HEX color encoding
   * @param {string} hex - HEX-encoded color string.
   * @return {boolean} If `true` the string is a valid HEX color encoding.
   */

  var isHex = function isHex(hex) {
    return /(^#[0-9A-Fa-f]{6}$)|(^#[0-9A-Fa-f]{3}$)/i.test(hex);
  };
  /**
   * Tests if a number is in `[0,1]`.
   * @param {number} x - Number to be tested.
   * @return {boolean} If `true` the number is in `[0,1]`.
   */

  var isNormFloat = function isNormFloat(x) {
    return isNumber(x) && x >= 0 && x <= 1;
  };
  /**
   * Tests if an array consist of normalized numbers that are in `[0,1]` only.
   * @param {array} a - Array to be tested
   * @return {boolean} If `true` the array contains only numbers in `[0,1]`.
   */

  var isNormFloatArray = function isNormFloatArray(a) {
    return Array.isArray(a) && a.every(isNormFloat);
  };
  /**
   * Test if a variable is a number
   * @param {*} x - Variable to be tested
   * @return {boolean} If `true`, `x` is a number.
   */

  var isNumber = function isNumber(x) {
    return typeof x === 'number';
  };
  /**
   * Test if a variable is a plain object, e.g., `{}`
   * @param {*} o - The variable to test
   * @return {boolean} If `true` the variable is a plain object.
   */

  var isObject = function isObject(o) {
    return !!o && o.constructor === Object;
  };
  /**
   * Tests if an array is encoding an RGB color.
   * @param {array} rgb - Array to be tested
   * @return {boolean} If `true` the array hold a triple of Uint8 numbers or
   *   a triple of normalized floats.
   */

  var isRgbArray = function isRgbArray(rgb) {
    return rgb.length === 3 && (isNormFloatArray(rgb) || isUint8Array(rgb));
  };
  /**
   * Tests if an array is encoding an RGBA color.
   * @param   {array}  rgb  Array to be tested
   * @return  {boolean}  If `true` the array hold a quadruple of normalized floats,
   *   a quadruple of Uint8s, or a triple of Uint8 and one normalized float.
   */

  var isRgbaArray = function isRgbaArray(rgba) {
    return rgba.length === 4 && (isNormFloatArray(rgba) || isUint8Array(rgba) || isUint8Array(rgba.slice(0, 3)) && isNormFloat(rgba[3]));
  };
  /**
   * Tests if a string is encoding an RGB color.
   * @param {string} rgb - String to be tested
   * @return {boolean} If `true` the array hold a triple of Uint8 numbers or
   *   a triple of normalized floats.
   */

  var isRgbStr = function isRgbStr(str) {
    return /rgb\(\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*\)/i.test(str);
  };
  /**
   * Tests if a string is encoding an RGBA color.
   * @param {string} rgb - String to be tested
   * @return {boolean} If `true` the array hold a quadruple of Uint8 numbers or
   *   a quadruple of normalized floats.
   */

  var isRgbaStr = function isRgbaStr(str) {
    return /rgba\(\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*,\s*[\d.]+\s*\)/i.test(str);
  };
  /**
   * Tests if a variable is a string
   * @param {*} s - Variable to be tested
   * @return {boolean} If `true` variable is a string
   */

  var isString = function isString(s) {
    return typeof s === 'string' || s instanceof String;
  };
  /**
   * Tests if a number is an interger and in `[0,255]`.
   * @param {number} x - Number to be tested.
   * @return {boolean} If `true` the number is an interger and in `[0,255]`.
   */

  var isUint8 = function isUint8(x) {
    return Number.isInteger(x) && x >= 0 && x <= 255;
  };
  /**
   * Tests if an array consist of Uint8 numbers only.
   * @param {array} a - Array to be tested.
   * @return {boolean} If `true` the array contains only Uint8 numbers.
   */

  var isUint8Array = function isUint8Array(a) {
    return Array.isArray(a) && a.every(isUint8);
  };

  /**
   * Aggregate a vector using one or more aggregators. Like a multi-purpose reducer.
   * @param {array} v - Numerivcal vector
   * @param {array|function} aggregater - A single or multiple aggregator functions. The aggregator functions work like reducers.
   * @param {array|number} startValue - A single or multiple start values
   * @param {function} options.getter - A value getter
   * @return {array|number} A single or multiple aggregagted values
   */

  var aggregate = function aggregate(v, aggregater, startValue) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
        _ref$getter = _ref.getter,
        getter = _ref$getter === void 0 ? identity : _ref$getter;

    var isSingle = isFunction(aggregater);
    var aggregaters = isSingle ? [aggregater] : aggregater;
    var startValues = isSingle ? [startValue] : startValue;
    var out = v.reduce(function (aggregates, x) {
      return aggregaters.map(function (fn, i) {
        return fn(aggregates[i], getter(x));
      });
    }, startValues === undefined ? Array(aggregaters.length).fill(0) : startValues);
    return isSingle ? out[0] : out;
  };
  /**
   * Get the difference of two vectoe
   * @param {array} v - Numerical vectors
   * @param {array} w - Numerical vectors
   * @return {array} Difference vector
   */

  var diff = function diff(v, w) {
    return v.map(function (x, i) {
      return x - w[i];
    });
  };
  /**
   * L distance between a pair of vectors
   *
   * @param {array} l - Defines the Lp space
   * @param {number} dim - Dimension of the input data (Optional)
   */

  var lDist = function lDist(l, dim) {
    if (Number.isNaN(+dim)) {
      /**
       * L distance function
       * @param {array} v - First vector
       * @param {array} w - Second vector
       * @return {array} L distance
       */
      return function (v, w) {
        return v.length === w.length ? Math.pow(v.reduce(function (sum, x, i) {
          return sum + Math.pow(Math.abs(x - w[i]), l);
        }, 0), 1 / l) : undefined;
      };
    }

    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.abs(v[".concat(i, "] - w[").concat(i, "]) ** l;");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "const l = ".concat(l, "; let s = 0; ").concat(body, " return s ** (1 / l);"));
  };
  /**
   * L1 distance between a pair of vectors
   *
   * @description
   * This is identical but much faster than `lDist(1)(v, w)`
   *
   * @param {array} v - First vector
   * @param {array} w - Second vector
   * @return {array} L2 distance
   */

  var l1Dist = function l1Dist(v, w) {
    return v.length === w.length ? v.reduce(function (sum, x, i) {
      return sum + Math.abs(x - w[i]);
    }, 0) : undefined;
  };
  /**
   * Creates a l1 distance function tailored to the dimension of the data
   *
   * @description
   * This is identical but faster than `l1Dist(v, w)`
   *
   * @param {number} dim - Dimension of the input data
   * @return {function} A function with the same signature as `l1Dist`
   */

  var l1DistByDim = function l1DistByDim(dim) {
    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.abs(v[".concat(i, "] - w[").concat(i, "]);");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "let s = 0; ".concat(body, " return s;"));
  };
  /**
   * L2 distance between a pair of vectors
   *
   * @description
   * This is identical but much faster than `lDist(2)(v, w)`
   *
   * @param {array} v - First vector
   * @param {array} w - Second vector
   * @return {array} L2 distance
   */

  var l2Dist = function l2Dist(v, w) {
    return v.length === w.length ? Math.sqrt(v.reduce(function (sum, x, i) {
      return sum + Math.pow(x - w[i], 2);
    }, 0)) : undefined;
  };
  /**
   * Creates a l2 distance function tailored to the dimension of the data
   *
   * @description
   * This is identical but faster than `l2Dist(v, w)`
   *
   * @param {number} dim - Dimension of the input data
   * @return {function} A function with the same signature as `l2Dist`
   */

  var l2DistByDim = function l2DistByDim(dim) {
    var body = Array(dim).fill().map(function (_, i) {
      return "s += Math.pow(v[".concat(i, "] - w[").concat(i, "], 2);");
    }).join(' '); // eslint-disable-next-line no-new-func

    return new Function('v', 'w', "let s = 0; ".concat(body, " return Math.sqrt(s);"));
  };
  /**
   * Vector L2 norm
   *
   * @description
   * This is identical but much faster than `Math.hypot(...v)`
   *
   * @param {array} v - Numerical vector
   * @return {number} L2 norm
   */

  var l2Norm = function l2Norm(v) {
    return Math.sqrt(v.reduce(function (sum, x) {
      return sum + Math.pow(x, 2);
    }, 0));
  };
  /**
   * Get the maximum number of a vector while ignoring NaNs
   *
   * @description
   * This version is muuuch faster than `Math.max(...v)`.
   *
   * @param {array} v - Numerical vector
   * @return {number} The largest number
   */

  var max = function max(v) {
    return v.reduce(function (_max, a) {
      return a > _max ? a : _max;
    }, -Infinity);
  };
  var maxNan = max;
  /**
   * Get the max vector
   * @param {array} m - Array of vectors
   * @return {array} Max vector
   */

  var maxVector = function maxVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_max, v) {
          return v.map(function (x, i) {
            return _max[i] > x ? _max[i] : x;
          });
        }, new Array(m[0].length).fill(-Infinity));
    }
  };
  /**
   * Get the mean of a vector
   *
   * @param {array} v - Numerical vector
   * @return {number} The mean
   */

  var mean = function mean(v) {
    return sum(v) / v.length;
  };
  /**
   * Get the mean of a vector while ignoring NaNs
   *
   * @description
   * Roughly 30% slower than `mean()`
   *
   * @param {array} v - Numerical vector
   * @return {number} The mean
   */

  var meanNan = function meanNan(v) {
    var length = 0;
    return v.reduce(function (s, x) {
      if (x || x === 0) return ++length && s + x;
      return s;
    }, 0) / length;
  };
  /**
   * Get the mean vector
   * @param {array} m - Array of vectors
   * @return {array} Mean vector
   */

  var meanVector = function meanVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_mean, v) {
          return v.map(function (x, i) {
            return _mean[i] + x / m.length;
          });
        }, new Array(m[0].length).fill(0));
    }
  };
  /**
   * Get the median of a vector
   *
   * @param {array} v - Numerical vector
   * @return {number} The median
   */

  var median = function median(v) {
    return v[Math.floor(v.length / 2)];
  };
  /**
   * Get the median vector
   * @param {array} m - Array of vectors
   * @return {array} The median vector
   */

  var medianVector = median;
  /**
   * Get the minimum number of a vector while ignoring NaNs
   *
   * @description
   * This version is muuuch faster than `Math.min(...v)` and support longer
   * vectors than 256^2, which is a limitation of `Math.min.apply(null, v)`.
   *
   * @param {array} v - Numerical vector
   * @return {number} The smallest number
   */

  var min = function min(v) {
    return v.reduce(function (_min, a) {
      return a < _min ? a : _min;
    }, Infinity);
  };
  var minNan = min;
  /**
   * Get the min vector
   * @param {array} m - Array of vectors
   * @return {array} Min vector
   */

  var minVector = function minVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_min, v) {
          return v.map(function (x, i) {
            return _min[i] < x ? _min[i] : x;
          });
        }, new Array(m[0].length).fill(Infinity));
    }
  };
  /**
   * Non-negative modulo function. E.g., `mod(-1, 5) === 4` while `-1 % 5 === -1`.
   *
   * @param {number} x - Dividend
   * @param {number} y - Divisor
   * @return {number} Remainder
   */

  var mod = function mod(x, y) {
    return (x % y + x) % y;
  };
  /**
   * Normalize vector
   * @param {array} v - Numerical vector
   * @return {array} Unit vector
   */

  var normalize = function normalize(v) {
    var norm = l2Norm(v);
    return v.map(function (x) {
      return x / norm;
    });
  };
  /**
   * Initialize an array of a certain length using a mapping function
   *
   * @description
   * This is equivalent to `Array(length).fill().map(mapFn)` but about 60% faster
   *
   * @param {number} length - Size of the array
   * @param {function} mapFn - Mapping function
   * @return {array} Initialized array
   */

  var rangeMap = function rangeMap(length) {
    var mapFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (x) {
      return x;
    };
    var out = [];

    for (var i = 0; i < length; i++) {
      out.push(mapFn(i, length));
    }

    return out;
  };
  /**
   * A function to created a range array
   * @param   {number}  start  Start of the range (included)
   * @param   {number}  end  End of the range (excluded)
   * @param   {number}  stepSize  Increase per step
   * @return  {array}  Range array
   */

  var range = function range(start, end) {
    var stepSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var realStepSize = stepSize * Math.sign(end - start);
    if (Number.isNaN(+end)) return rangeMap(start);
    return rangeMap(Math.ceil(Math.abs(end - start) / Math.abs(stepSize)), function (i) {
      return start + i * realStepSize;
    });
  };
  /**
   * Get the sum of a vector while ignoring NaNs
   *
   * @example
   * sum([0, 10, 12, 22])
   * // >> 42
   *
   * @param {array} v - Numerical vector
   * @return {number} The sum
   */

  var sum = function sum(values) {
    return values.reduce(function (s, v) {
      // Any falsey value (e.g., 0, null, NaN) does not influence the sum
      if (v) return s + v;
      return s;
    }, 0);
  };
  var sumNan = sum;
  /**
   * Get the sum vector
   * @param {array} m - Array of vectors
   * @return {array} Sum vector
   */

  var sumVector = function sumVector(m) {
    switch (m.length) {
      case 0:
        return [];

      case 1:
        return m[0];

      default:
        return m.reduce(function (_sum, v) {
          return v.map(function (x, i) {
            return _sum[i] + x;
          });
        }, new Array(m[0].length).fill(0));
    }
  };
  /**
   * Get the unique union of two vectors of integers
   * @param {array} v - First vector of integers
   * @param {array} w - Second vector of integers
   * @return {array} Unique union of `v` and `w`
   */

  var unionIntegers = function unionIntegers(v, w) {
    var a = [];
    v.forEach(function (x) {
      a[x] = true;
    });
    w.forEach(function (x) {
      a[x] = true;
    });
    return a.reduce(function (union, value, i) {
      if (value) union.push(i);
      return union;
    }, []);
  };

  /**
   * Convert a HEX string to its decimal representation
   * @param {string} hex - HEX string
   * @return {number} Decimal representation
   */

  var decToRgb = function decToRgb(dec) {
    return [dec >> 16, (dec >> 8) % 256, dec % 256];
  };
  /**
   * Convert a HEX string to its decimal representation
   * @param {string} hex - HEX string
   * @return {number} Decimal representation
   */

  var hexToDec = function hexToDec(hex) {
    return parseInt(hex.substr(1), 16);
  };
  /**
   * Convert a HEX-encoded color to an RGB-encoded color
   * @param {string} hex - HEX-encoded color string.
   * @param {boolean} normalize - If `true` the returned RGB values will be
   *   normalized to `[0,1]`.
   * @return {array} Triple holding the RGB values.
   */

  var hexToRgbArray = function hexToRgbArray(hex) {
    var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
      return "#".concat(r).concat(r).concat(g).concat(g).concat(b).concat(b);
    }).substring(1).match(/.{2}/g).map(function (x) {
      return parseInt(x, 16) / Math.pow(255, normalize);
    });
  };
  /**
   * Convert a HEX-encoded color to an RGBA-encoded color
   * @param {string} hex - HEX-encoded color string.
   * @param {boolean} normalize - If `true` the returned RGBA values will be
   *   normalized to `[0,1]`.
   * @return {array} Triple holding the RGBA values.
   */

  var hexToRgbaArray = function hexToRgbaArray(hex) {
    var normalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return [].concat(_toConsumableArray__default['default'](hexToRgbArray(hex, normalize)), [Math.pow(255, !normalize)]);
  };
  /**
   * Convert RGB(A) string to its array representation
   * @param {string} rgbStr - RGB(A) string
   * @return {number} RGB(A) array
   */

  var rgbStrToRgbArray = function rgbStrToRgbArray(rgbStr) {
    return rgbStr.match(/[\d.]+/g).slice(0, 4).map(function (x) {
      return +x;
    });
  };
  /**
   * Same as `rgbStrToRgbArray()`
   */

  var rgbaStrToRgbaArray = rgbStrToRgbArray;
  /**
   * Convert RGB string to its decimal representation
   * @param {string} rgbStr - RGB string
   * @return {number} Decimal representation
   */

  var rgbStrToDec = function rgbStrToDec(rgbStr) {
    return rgbStrToRgbArray(rgbStr).slice(0, 3) // eslint-disable-next-line no-bitwise
    .map(function (x, i) {
      return +x << 8 * (2 - i);
    }).reduce(function (x, sum) {
      return sum + x;
    }, 0);
  };
  /**
   * Convert RGB values to a HEX string
   * @param {number} r - Red component
   * @param {number} g - Green component
   * @param {number} b - Blue component
   * @return {string} HEX string
   */

  var rgbToHex = function rgbToHex(r, g, b) {
    var componentToHex = function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length === 1 ? "0".concat(hex) : hex;
    };

    return "#".concat(componentToHex(r)).concat(componentToHex(g)).concat(componentToHex(b));
  };
  /**
   * Convert a color to an RGBA color
   * @param {*} color - Color to be converted. Currently supports:
   *   HEX, RGB, or RGBA.
   * @param {boolean} normalize - If `true` the returned RGBA values will be
   *   normalized to `[0,1]`.
   * @return{array} Quadruple defining an RGBA color.
   */

  var toRgbaArray = function toRgbaArray(color, normalize$1) {
    if (isRgbaArray(color)) return normalize$1 && !isNormFloatArray(color) ? normalize$1(color) : color;
    if (isRgbArray(color)) return [].concat(_toConsumableArray__default['default'](normalize$1 ? normalize(color) : color), [Math.pow(255, !normalize$1)]);
    if (isHex(color)) return hexToRgbaArray(color, normalize$1);
    console.warn('Only HEX, RGB, and RGBA are handled by this function. Returning white instead.');
    return normalize$1 ? [1, 1, 1, 1] : [255, 255, 255, 255];
  };

  function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  /**
   * Store the values of an iterator in an array.
   *
   * This code is about 9x faster than `Array.from()`
   *
   * @param   {map}  map  The map whose keys are to be converted to an array
   * @return  {array}  The array with the map keys
   */
  var iteratorToArray = function iteratorToArray(iterator) {
    var keys = []; // eslint-disable-next-line no-restricted-syntax

    var _iterator = _createForOfIteratorHelper(iterator),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        keys.push(value);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return keys;
  };

  var XMLNS = 'http://www.w3.org/2000/svg';
  /**
   * Method to add a class name to an HTML or SVG element.
   * @param {object} element - HTML or SVG element to add a class to.
   * @param {string} className - The class name to be added.
   */

  var addClass = function addClass(element, className) {
    if (element.namespaceURI === XMLNS) {
      if (!hasClass(element, className)) {
        var klass = element.getAttribute('class') || '';
        element.setAttribute('class', "".concat(klass, " ").concat(className));
      }
    } else if (element.classList) {
      element.classList.add(className);
    } else if (!hasClass(element, className)) {
      element.className += " ".concat(className);
    }
  };
  /**
   * Create HTML from a template string
   * @param {string} template - HTML template string
   * @return {node} Root DOM element
   */

  var createHtmlByTemplate = function createHtmlByTemplate(template) {
    var dummyEl = document.createElement('div');
    dummyEl.insertAdjacentHTML('beforeend', template);
    return dummyEl.firstChild;
  };
  /**
   * Check if an HTML or SVG element has a certain class
   * @param {object} element - HTML or SVG element to be checked
   * @param {string} className - Class name to be checked for
   * @return {boolean} If `true` `element` has the class name
   */

  var hasClass = function hasClass(element, className) {
    if (element.namespaceURI === XMLNS) {
      var klass = element.getAttribute('class');
      return klass && !!klass.match(new RegExp("(\\s|^)".concat(className, "(\\s|$)")));
    }

    if (element.classList) return element.classList.contains(className);
    return !!element.className.match(new RegExp("(\\s|^)".concat(className, "(\\s|$)")));
  };
  /**
   * Test whether a DOM element is the parent of another DOM element.
   *
   * @param {object} element - Potential child element.
   * @param {object} parent - Target parent element which is tested to have `el`
   *   as a child.
   * @return {boolean} If `true` `parent` is a parent of `element`.
   */

  var isParentOf = function isParentOf(element, parent) {
    var el = element;

    while (el && el !== parent && el.tagName !== 'HTML') {
      el = el.parentNode;
    }

    return el === parent;
  };
  /**
   * Remove all children of a DOM node
   * @param {object} node - DOM node whose children are to be removed
   */

  var removeAllChildren = function removeAllChildren(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  };
  /**
   * Remove last child of a DOM node
   * @param {object} node - DOM node whose last child is to be removed
   */

  var removeLastChild = function removeLastChild(node) {
    node.removeChild(node.lastChild);
  };
  /**
   * Remove a class from an HTML or SVG element.
   * @param {object} element - HTML or SVG element.
   * @param {string} className - Class name to be removed.
   */

  var removeClass = function removeClass(element, className) {
    var reg = new RegExp("(\\s|^)".concat(className, "(\\s|$)"));

    if (element.namespaceURI === XMLNS) {
      var klass = element.getAttribute('class') || '';
      element.setAttribute('class', klass.replace(reg, ' '));
    } else if (element.classList) {
      element.classList.remove(className);
    } else if (hasClass(element, className)) {
      element.className = element.className.replace(reg, ' ');
    }
  };

  /**
   * Clone an event by invoking the source event's constructor and passing in
   *   the source event.
   *
   * @param {object} event - Source event to be cloned.
   * @return {object} Cloned event
   */
  var cloneEvent = function cloneEvent(event) {
    var newEvent = new event.constructor(event.type, event);
    newEvent.sourceUid = event.sourceUid;
    newEvent.forwarded = event.forwarded;
    return newEvent;
  };
  /**
   * Forward an event by cloning and dispatching it.
   * @param {object} event - Event to be forwarded.
   * @param {object} target - Target HTML element for the event.
   */

  var forwardEvent = function forwardEvent(event, target) {
    target.dispatchEvent(cloneEvent(event));
  };

  var assign = function assign(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
      // eslint-disable-next-line no-shadow
      var descriptors = Object.keys(source).reduce(function (descriptors, key) {
        descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
        return descriptors;
      }, {}); // By default, Object.assign copies enumerable Symbols, too

      Object.getOwnPropertySymbols(source).forEach(function (symbol) {
        var descriptor = Object.getOwnPropertyDescriptor(source, symbol);

        if (descriptor.enumerable) {
          descriptors[symbol] = descriptor;
        }
      });
      Object.defineProperties(target, descriptors);
    });
    return target;
  };
  /**
   * Deep clone an object.
   *
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object.
   */

  var deepClone = function deepClone(source) {
    var target;
    return extend(target, source);
  };
  /**
   * Extend an object with another object.
   *
   * @param {object} target - Target object or `undefined` if a new object should
   *   be created.
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object
   */

  var extend = function extend(target, source) {
    if (source === null || _typeof__default['default'](source) !== 'object') {
      return source;
    }

    if (source.constructor !== Object && source.constructor !== Array) {
      return source;
    }

    if (source.constructor === Date || source.constructor === RegExp || source.constructor === Function || source.constructor === String || source.constructor === Number || source.constructor === Boolean) {
      return new source.constructor(source);
    }

    var out = target || new source.constructor();
    Object.keys(source).forEach(function (key) {
      var descriptor = Object.getOwnPropertyDescriptor(source, key);

      if (typeof out[key] === 'undefined') {
        if (typeof descriptor.value === 'undefined') {
          Object.defineProperty(out, key, descriptor);
        } else {
          out[key] = extend(undefined, source[key]);
        }
      }
    });
    return out;
  };
  /**
   * Update the target object by the source object. Besides extending that target
   * object, properties that are not present in the source object.
   *
   * @param {object} target - Target object or `undefined` if a new object should
   *   be created.
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object
   */

  var update = function update(target, source) {
    // Return boolean, number, strings, and null
    if (source === null || _typeof__default['default'](source) !== 'object') {
      return source;
    } // Recreate special objects. Special objects are of type "object" but are not
    // simple arrays or objects, e.g.:
    // Date, RegExp, String, Number, Boolean, or Function


    if (source.constructor !== Object && source.constructor !== Array) {
      return new source.constructor(source);
    }

    var out = new target.constructor(); // Update properties

    var updated = false;
    Object.keys(source).forEach(function (key) {
      var descriptor = Object.getOwnPropertyDescriptor(source, key);

      if (target[key] === undefined) {
        // The `key` prop does not exist on `target` so we will extend `target`
        // with the `key` prop.
        if (typeof descriptor.value === 'undefined') {
          Object.defineProperty(out, key, descriptor);
        } else {
          out[key] = extend(undefined, source[key]);
        }
      } else {
        // The `key` prop exist on `target` so we update it.
        out[key] = update(target[key], source[key]);
      }

      updated = updated || out[key] !== target[key];
    }); // In case no property was updated but some were removed `updated` needs to be
    // true

    updated = updated || Object.keys(target).filter(function (key) {
      return typeof source[key] === 'undefined';
    }).length;
    return updated ? out : target;
  };

  var camelToConst = function camelToConst(str) {
    return str.split(/(?=[A-Z])/).join('_').toUpperCase();
  };
  var capitalize = function capitalize(str) {
    return "".concat(str[0].toUpperCase()).concat(str.substr(1));
  };
  /**
   * FInd the nth instance of the query string
   * @param   {string}  str  String to search across
   * @param   {string}  query  String to search for
   * @param   {number}  n  nth instance
   * @return  {number}  Index of the nth query string or -1
   */

  var nthIndexOf = function nthIndexOf(str, query) {
    var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = 0;
    var idx = str.indexOf(query);

    while (i < n && idx >= 0) {
      idx = str.indexOf(query, idx + 1);
      i++;
    }

    return idx;
  };
  /**
   * Create a random string from some alphabet
   * @param {number} length - Length of the random string
   * @param {string} alphabet - Possible characters
   * @return {string} Random string
   */

  var randomString = function randomString(length) {
    var alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'abcdefghijklmnopqrstuvwxyz';
    return Array(length).join().split(',').map(function () {
      return alphabet.charAt(Math.floor(Math.random() * alphabet.length));
    }).join('');
  };

  /**
   * Functional version of `Array.map()`
   *
   * @description
   * The pure map function is more powerful because it can be used on data types
   * other than Array too.
   *
   * @param {function} f - Mapping function
   * @return {array} Mapped array
   */

  var map = function map(f) {
    return function (x) {
      return Array.prototype.map.call(x, f);
    };
  };
  /**
   * Map and filter data in one iteration.
   *
   * Combining the loops is about 7-8x faster than
   *
   * @param   {function}  mapFn  Mapping function
   * @param   {function}  filterFn  Filter function
   * @return  {function}  A function that accepts a single array paremeter
   */

  var mapFilter = function mapFilter(mapFn, filterFn) {
    return (
      /**
       * @param   {array}  arr  An array to be mapped and filtered
       * @returns {array}  The mapped and filtered array
       */
      function (arr) {
        var out = []; // loop though array

        for (var i = 0; i < arr.length; i++) {
          var result = mapFn(arr[i], i);
          if (filterFn(result, out.length)) out.push(result);
        }

        return out;
      }
    );
  };
  /**
   * Functional version of `Array.forEach`
   *
   * @description
   * More flexible and applicable to other array-like data types.
   *
   * @param {function} f - Modifier function applied on every item of the array.
   * @return {array} Modified array-like variable.
   */

  var forEach = function forEach(f) {
    return function (x) {
      return Array.prototype.forEach.call(x, f);
    };
  };
  /**
   * Convenience function to compose functions
   * @param {...function} fns - Array of functions
   * @return {function} The composed function
   */

  var pipe = function pipe() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }

    return (
      /**
       * @param {*} x - Some value
       * @return {*} Output of the composed function
       */
      function (x) {
        return fns.reduce(function (y, f) {
          return f(y);
        }, x);
      }
    );
  };
  /**
   * Functional version of `Array.forEach`. More flexible and applicable to
   *   other array-like data types like `NodeList`.
   * @param   {function}  f  Modifier function applied on every item of the
   *   array.
   * @return  {*}  Modified array-like variable.
   */

  var some = function some(f) {
    return function (x) {
      return Array.prototype.some.call(x, f);
    };
  };
  /**
   * Assign a constructor to the object
   * @param {function} constructor - Constructor functions
   */

  var withConstructor = function withConstructor(constructor) {
    return function (self) {
      return assign({
        __proto__: {
          constructor: constructor
        }
      }, self);
    };
  };
  /**
   * Forward a method call
   * @param {string} name - Exposed function name
   * @param {function} fn - Function to be forwarded
   */

  var withForwardedMethod = function withForwardedMethod(name, fn) {
    return function (self) {
      return assign(self, _defineProperty__default['default']({}, name, function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return fn.apply(this, args);
      }));
    };
  };
  /**
   * Assign a property to an object
   * @param {string} name - Name of the property
   * @param {object} options - Option object
   * @param {*} options.initialValue - Initial value of the property
   * @param {function} options.getter - Custom getter
   * @param {function} options.setter - Custom setter
   * @param {function} options.cloner - Clone function. Used before the value
   *   is returned.
   * @param {function} options.transformer - Value transformer. Used before a new
   *   value is set.
   * @param {function} options.validator - Validator function decides whether the
   *   new and transformed value is set or not.
   */

  var withProperty = function withProperty(name) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$initialValue = _ref.initialValue,
        initialValue = _ref$initialValue === void 0 ? undefined : _ref$initialValue,
        customGetter = _ref.getter,
        customSetter = _ref.setter,
        _ref$cloner = _ref.cloner,
        cloner = _ref$cloner === void 0 ? identity : _ref$cloner,
        _ref$transformer = _ref.transformer,
        transformer = _ref$transformer === void 0 ? identity : _ref$transformer,
        _ref$validator = _ref.validator,
        validator = _ref$validator === void 0 ? function () {
      return true;
    } : _ref$validator;

    return function (self) {
      var _assign2, _mutatorMap;

      var value = initialValue;
      var getter = customGetter ? function () {
        return customGetter();
      } : function () {
        return cloner(value);
      };
      var setter = customSetter ? function (newValue) {
        return customSetter(newValue);
      } : function (newValue) {
        var transformedNewValue = transformer(newValue);
        value = validator(transformedNewValue) ? transformedNewValue : value;
      };
      return assign(self, (_assign2 = {}, _mutatorMap = {}, _mutatorMap[name] = _mutatorMap[name] || {}, _mutatorMap[name].get = function () {
        return getter();
      }, _defineProperty__default['default'](_assign2, "set".concat(capitalize(name)), function set(newValue) {
        setter(newValue);
      }), _defineEnumerableProperties__default['default'](_assign2, _mutatorMap), _assign2));
    };
  };
  /**
   * Assign a read-only property to an object
   * @param {string} name - Name of the property
   * @param {function} getter - Getter function
   */

  var withReadOnlyProperty = function withReadOnlyProperty(name, getter) {
    return function (self) {
      var _assign3, _mutatorMap2;

      return assign(self, (_assign3 = {}, _mutatorMap2 = {}, _mutatorMap2[name] = _mutatorMap2[name] || {}, _mutatorMap2[name].get = function () {
        return getter();
      }, _defineEnumerableProperties__default['default'](_assign3, _mutatorMap2), _assign3));
    };
  };
  /**
   * Assign a static property to an object
   * @param {string} name - Name of the property
   * @param {*} value - Static value
   */

  var withStaticProperty = function withStaticProperty(name, value) {
    return function (self) {
      var _assign4, _mutatorMap3;

      return assign(self, (_assign4 = {}, _mutatorMap3 = {}, _mutatorMap3[name] = _mutatorMap3[name] || {}, _mutatorMap3[name].get = function () {
        return value;
      }, _defineEnumerableProperties__default['default'](_assign4, _mutatorMap3), _assign4));
    };
  };

  /**
   * L distance between a pair of vectors
   *
   * @description
   * Identical but much faster than `lDist(l)([fromX, fromY], [toX, toY])`
   *
   * @param {number} l - Defines the Lp space
   */
  var lPointDist = function lPointDist(l) {
    return (
      /**
       * L distance function
       * @param {number} fromX - X coordinate of the first point
       * @param {number} fromY - Y coordinate of the first point
       * @param {number} toX - X coordinate of the second point
       * @param {number} toY - Y coordinate of the first point
       * @return {array} L distance
       */
      function (fromX, fromY, toX, toY) {
        return Math.pow(Math.pow(Math.abs(fromX - toX), l) + Math.pow(Math.abs(fromY - toY), l), 1 / l);
      }
    );
  };
  /**
   * L1 distance between a pair of points
   *
   * @description
   * Identical but much faster than `l1Dist([fromX, fromY], [toX, toY])`
   *
   * @param {number} fromX - X coordinate of the first point
   * @param {number} fromY - Y coordinate of the first point
   * @param {number} toX - X coordinate of the second point
   * @param {number} toY - Y coordinate of the first point
   * @return {number} L1 distance
   */

  var l1PointDist = function l1PointDist(fromX, fromY, toX, toY) {
    return Math.abs(fromX - toX) + Math.abs(fromY - toY);
  };
  /**
   * L2 distance between a pair of points
   *
   * @description
   * Identical but much faster than `l2Dist([fromX, fromY], [toX, toY])`
   *
   * @param {number} fromX - X coordinate of the first point
   * @param {number} fromY - Y coordinate of the first point
   * @param {number} toX - X coordinate of the second point
   * @param {number} toY - Y coordinate of the first point
   * @return {number} L2 distance
   */

  var l2PointDist = function l2PointDist(fromX, fromY, toX, toY) {
    return Math.sqrt(Math.pow(fromX - toX, 2) + Math.pow(fromY - toY, 2));
  };
  /**
   * L distance between a pair of rectangles
   *
   * @param {number} l - Defines the Lp space
   */

  var lRectDist = function lRectDist(l) {
    return (
      /**
       * L distance function between a pair of rectangles
       *
       * @param {object} bBox1 - Bounding box of the first rectangle
       * @param {object} bBox2 - Bounding box of the second rectangle
       * @return {number} L distance of the closest boundary points
       */
      function (bBox1, bBox2) {
        var xd1 = bBox2.minX - bBox1.minX;
        var xd2 = bBox2.minX - bBox1.maxX;
        var xd3 = bBox2.maxX - bBox1.minX;
        var xd4 = bBox2.maxX - bBox1.maxX;
        var isXInside = // bBox1 is x-wise inside of bBox2
        xd1 < 0 && xd3 > 0 || xd2 < 0 && xd4 > 0 || // bBox2 is x-wise inside of bBox1
        xd1 > 0 && xd2 < 0 || xd3 > 0 && xd4 < 0;
        var yd1 = bBox2.minY - bBox1.minY;
        var yd2 = bBox2.minY - bBox1.maxY;
        var yd3 = bBox2.maxY - bBox1.minY;
        var yd4 = bBox2.maxY - bBox1.maxY;
        var isYInside = // bBox1 is y-wise inside of bBox2
        yd1 < 0 && yd3 > 0 || yd2 < 0 && yd4 > 0 || // bBox2 is y-wise inside of bBox1
        yd1 > 0 && yd2 < 0 || yd3 > 0 && yd4 < 0;
        if (isXInside && isYInside) return 0;
        var minYDist = Math.min(Math.abs(yd1), Math.abs(yd2), Math.abs(yd3), Math.abs(yd4));
        if (isXInside) return minYDist;
        var minXDist = Math.min(Math.abs(xd1), Math.abs(xd2), Math.abs(xd3), Math.abs(xd4));
        if (isYInside) return minXDist;
        return Math.pow(Math.pow(minXDist, l) + Math.pow(minYDist, l), 1 / l);
      }
    );
  };
  /**
   * From: https://wrf.ecse.rpi.edu//Research/Short_Notes/pnpoly.html
   * @param   {Array}  point  Tuple of the form `[x,y]` to be tested.
   * @param   {Array}  polygon  1D list of vertices defining the polygon.
   * @return  {boolean}  If `true` point lies within the polygon.
   */

  var isPointInPolygon = function isPointInPolygon() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],
        _ref2 = _slicedToArray__default['default'](_ref, 2),
        px = _ref2[0],
        py = _ref2[1];

    var polygon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var x1;
    var y1;
    var x2;
    var y2;
    var isWithin = false;

    for (var i = 0, j = polygon.length - 2; i < polygon.length; i += 2) {
      x1 = polygon[i];
      y1 = polygon[i + 1];
      x2 = polygon[j];
      y2 = polygon[j + 1];
      if (y1 > py !== y2 > py && px < (x2 - x1) * (py - y1) / (y2 - y1) + x1) isWithin = !isWithin;
      j = i;
    }

    return isWithin;
  };
  /**
   * Check if a 2D or 1D point is within a rectangle or range
   * @param   {number}  x  The point's X coordinate.
   * @param   {number}  y  The point's Y coordinate.
   * @param   {number}  minX  The rectangle's start X coordinate.
   * @param   {number}  maxX  The rectangle's start X coordinate.
   * @param   {number}  minY  The rectangle's start X coordinate.
   * @param   {number}  maxY  The rectangle's start X coordinate.
   * @return  {boolean}  If `true` the [x,y] point is in the rectangle.
   */

  var isPointInRect = function isPointInRect(_ref3, _ref4) {
    var _ref5 = _slicedToArray__default['default'](_ref3, 2),
        x = _ref5[0],
        y = _ref5[1];

    var _ref6 = _slicedToArray__default['default'](_ref4, 4),
        minX = _ref6[0],
        maxX = _ref6[1],
        minY = _ref6[2],
        maxY = _ref6[3];

    return x >= minX && x <= maxX && y >= minY && y <= maxY;
  };
  /**
   * Check if a 2D or 1D point is within a rectangle or range
   * @param   {number}  x  The point's X coordinate.
   * @param   {number}  y  The point's Y coordinate.
   * @param   {number}  minX  The rectangle's start X coordinate.
   * @param   {number}  maxX  The rectangle's start X coordinate.
   * @param   {number}  minY  The rectangle's start X coordinate.
   * @param   {number}  maxY  The rectangle's start X coordinate.
   * @return  {boolean}  If `true` the [x,y] point is in the rectangle.
   */

  var isPointHalfwayInRect = function isPointHalfwayInRect(_ref7, _ref8) {
    var _ref9 = _slicedToArray__default['default'](_ref7, 2),
        x = _ref9[0],
        y = _ref9[1];

    var _ref10 = _slicedToArray__default['default'](_ref8, 4),
        minX = _ref10[0],
        maxX = _ref10[1],
        minY = _ref10[2],
        maxY = _ref10[3];

    return x >= minX && x <= maxX || y >= minY && y <= maxY;
  };

  var mergeMaps = function mergeMaps(map1, map2) {
    return new Map( /*#__PURE__*/_regeneratorRuntime__default['default'].mark(function merge() {
      return _regeneratorRuntime__default['default'].wrap(function merge$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(map1, "t0", 1);

            case 1:
              return _context.delegateYield(map2, "t1", 2);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, merge);
    })());
  };

  /**
   * Create a worker from a function
   * @param {function} fn - Function to be turned into a worker
   * @return {Worker} Worker function
   */
  var createWorker = function createWorker(fn) {
    return new Worker(window.URL.createObjectURL(new Blob(["(".concat(fn.toString(), ")()")], {
      type: 'text/javascript'
    })));
  };
  /**
   * An adventure into the void!
   * @return {undefined} The explorers find nothing but void.
   */

  var toVoid = function toVoid() {};
  var noop = toVoid;

  var sortAsc = function sortAsc(a, b) {
    return a - b;
  };
  var sortDesc = function sortDesc(a, b) {
    return b - a;
  };
  /**
   * Return a list of indices sorted by the array
   *
   * @example
   * const X = [9, 5, 11, -1, 0];
   * const sortedIdx = argSort(X);
   * // >> [3, 4, 1, 0, 2]
   * // I.e., the smallest element is X[sortedIdx[0]] == -1
   *
   * @param {array} array - Array of numerical values
   * @param {function} comparator - Pairwise value comparator function
   * @return {array} Array of indices sorted by the values
   */

  var argSort = function argSort(array) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$getter = _ref.getter,
        getter = _ref$getter === void 0 ? identity : _ref$getter,
        _ref$comparator = _ref.comparator,
        comparator = _ref$comparator === void 0 ? sortAsc : _ref$comparator,
        _ref$ignoreNull = _ref.ignoreNull,
        ignoreNull = _ref$ignoreNull === void 0 ? false : _ref$ignoreNull;

    return array.map(ignoreNull ? function (x, i) {
      return getter(x) === null ? undefined : [getter(x), i];
    } : function (x, i) {
      return [getter(x), i];
    }).sort(function (a, b) {
      return comparator(a[0], b[0]);
    }).reduce(function (out, tuple) {
      if (!tuple) return out;
      out.push(tuple[1]);
      return out;
    }, []);
  };
  /**
   * Return the sort position of each element in an array or object
   *
   * @example
   * let array = [9, 5, 11, -1, 0];
   * let pos = sortPos(array)
   * // >> [3, 2, 4, 0, 1]
   * // I.e., the first element of `array` is at position pos[0] == 3
   *
   * let object = { 1: 9, 2: 5, 11: 11, 100: -1, 999: 0 };
   * let pos = sortPos(object)
   * // >> { 1: 3, 2: 2, 11: 4, 100: 0, 999: 1 }
   * // I.e., element `999` of `object` is at position pos[999] == 1
   *
   * @param {array} array - Array of numerical values
   * @param {function} comparator - Pairwise value comparator function
   * @return {array} Array of the sorted value positions
   */

  var sortPos = function sortPos(source) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$getter = _ref2.getter,
        getter = _ref2$getter === void 0 ? identity : _ref2$getter,
        _ref2$comparator = _ref2.comparator,
        comparator = _ref2$comparator === void 0 ? sortAsc : _ref2$comparator,
        _ref2$ignoreNull = _ref2.ignoreNull,
        ignoreNull = _ref2$ignoreNull === void 0 ? false : _ref2$ignoreNull;

    return Object.entries(source).map(ignoreNull ? function (_ref3) {
      var _ref4 = _slicedToArray__default['default'](_ref3, 2),
          id = _ref4[0],
          x = _ref4[1];

      return getter(x) === null ? undefined : [id, getter(x)];
    } : function (_ref5) {
      var _ref6 = _slicedToArray__default['default'](_ref5, 2),
          id = _ref6[0],
          x = _ref6[1];

      return [id, getter(x)];
    }).sort(function (a, b) {
      return comparator(a[1], b[1]);
    }).reduce(function (out, tuple, i) {
      if (!tuple) return out;
      out[tuple[0]] = i;
      return out;
    }, new source.constructor());
  };

  /**
   * Debounce a function call.
   *
   * @description
   * Function calls are delayed by `wait` milliseconds and only one out of
   * multiple function calls is executed.
   *
   * @param {function} fn - Function to be debounced
   * @param {number} wait - Number of milliseconds to debounce the function call.
   * @return {function} Debounced function
   */
  var debounce = function debounce(fn, wait) {
    var timeout;

    var debounced = function debounced() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var later = function later() {
        timeout = null;
        fn.apply(void 0, args);
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };

    debounced.cancel = function () {
      clearTimeout(timeout);
    };

    debounced.now = function () {
      return fn.apply(void 0, arguments);
    };

    return debounced;
  };
  /**
   * Get a promise that resolves after the next `n` animation frames
   * @param {number} n - Number of animation frames to wait
   * @return {Promise} A promise that resolves after the next `n` animation frames
   */

  var nextAnimationFrame = function nextAnimationFrame() {
    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return new Promise(function (resolve) {
      var i = 0;

      var raf = function raf() {
        return requestAnimationFrame(function () {
          i++;
          if (i < n) raf();else resolve();
        });
      };

      raf();
    });
  };
  /**
   * Throttle a function
   *
   * @description
   * A throttled function will only ever be called every `wait` milliseconds at
   * most.
   *
   * @param {function} fn - Function to be throttled
   * @param {number} wait - Number of milliseconds calls are throttled
   * @return {function} Throttled function
   */

  var throttle = function throttle(fn, wait) {
    var isWaiting = false;

    var throttled = function throttled() {
      if (!isWaiting) {
        fn.apply(void 0, arguments);
        isWaiting = true;
        setTimeout(function () {
          isWaiting = false;
        }, wait);
      }
    };

    throttled.reset = function () {
      isWaiting = false;
    };

    throttled.now = function () {
      return fn.apply(void 0, arguments);
    };

    return throttled;
  };
  /**
   * Throttle and debounce a function call
   *
   * Throttling a function call means that the function is called at most every
   * `interval` milliseconds no matter how frequently you trigger a call.
   * Debouncing a function call means that the function is called the earliest
   * after `finalWait` milliseconds wait time where the function was not called.
   * Combining the two ensures that the function is called at most every
   * `interval` milliseconds and is ensured to be called with the very latest
   * arguments after after `finalWait` milliseconds wait time at the end.
   *
   * The following imaginary scenario describes the behavior:
   *
   * MS | throttleTime=3 and debounceTime=3
   * 1. y(f, 3, 3)(args1) => f(args1) called
   * 2. y(f, 3, 3)(args2) => call ignored due to throttling
   * 3. y(f, 3, 3)(args3) => call ignored due to throttling
   * 4. y(f, 3, 3)(args4) => f(args4) called
   * 5. y(f, 3, 3)(args5) => all ignored due to throttling
   * 6. No call           => nothing
   * 7. No call           => f(args5) called due to debouncing
   *
   * @param {functon} func - Function to be throttled and debounced
   * @param {number} interval - Throttle intevals in milliseconds
   * @param {number} wait - Debounce wait time in milliseconds By default this is
   *   the same as `interval`.
   * @return {function} - Throttled and debounced function
   */

  var throttleAndDebounce = function throttleAndDebounce(fn, throttleTime) {
    var debounceTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var timeout;
    var blockedCalls = 0; // eslint-disable-next-line no-param-reassign

    debounceTime = debounceTime === null ? throttleTime : debounceTime;

    var debounced = function debounced() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var later = function later() {
        // Since we throttle and debounce we should check whether there were
        // actually multiple attempts to call this function after the most recent
        // throttled call. If there were no more calls we don't have to call
        // the function again.
        if (blockedCalls > 0) {
          fn.apply(void 0, args);
          blockedCalls = 0;
        }
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, debounceTime);
    };

    var isWaiting = false;

    var throttledAndDebounced = function throttledAndDebounced() {
      if (!isWaiting) {
        fn.apply(void 0, arguments);
        debounced.apply(void 0, arguments);
        isWaiting = true;
        blockedCalls = 0;
        setTimeout(function () {
          isWaiting = false;
        }, throttleTime);
      } else {
        blockedCalls++;
        debounced.apply(void 0, arguments);
      }
    };

    throttledAndDebounced.reset = function () {
      isWaiting = false;
    };

    throttledAndDebounced.cancel = function () {
      clearTimeout(timeout);
    };

    throttledAndDebounced.now = function () {
      return fn.apply(void 0, arguments);
    };

    return throttledAndDebounced;
  };
  /**
   * Promise that resolves after some time
   * @param {number} msec - Time in milliseconds until the promise is resolved
   * @return {Promise} Promise resolving after `msec` milliseconds
   */

  var wait = function wait(msec) {
    return new Promise(function (resolve) {
      return setTimeout(resolve, msec);
    });
  };
  var timeout = wait;

  var version = "0.29.0";

  exports.addClass = addClass;
  exports.aggregate = aggregate;
  exports.argSort = argSort;
  exports.array2dTranspose = array2dTranspose;
  exports.assign = assign;
  exports.camelToConst = camelToConst;
  exports.capitalize = capitalize;
  exports.clamp = clamp;
  exports.clearArray = clearArray;
  exports.cloneEvent = cloneEvent;
  exports.createHtmlByTemplate = createHtmlByTemplate;
  exports.createWorker = createWorker;
  exports.cubicIn = cubicIn;
  exports.cubicInOut = cubicInOut;
  exports.cubicOut = cubicOut;
  exports.debounce = debounce;
  exports.decToRgb = decToRgb;
  exports.deepClone = deepClone;
  exports.diff = diff;
  exports.extend = extend;
  exports.forEach = forEach;
  exports.forwardEvent = forwardEvent;
  exports.hasClass = hasClass;
  exports.hexToDec = hexToDec;
  exports.hexToRgbArray = hexToRgbArray;
  exports.hexToRgbaArray = hexToRgbaArray;
  exports.identity = identity;
  exports.interpolateNumber = interpolateNumber;
  exports.interpolateVector = interpolateVector;
  exports.isArray = isArray;
  exports.isClose = isClose;
  exports.isFunction = isFunction;
  exports.isHex = isHex;
  exports.isNormFloat = isNormFloat;
  exports.isNormFloatArray = isNormFloatArray;
  exports.isNumber = isNumber;
  exports.isObject = isObject;
  exports.isParentOf = isParentOf;
  exports.isPointHalfwayInRect = isPointHalfwayInRect;
  exports.isPointInPolygon = isPointInPolygon;
  exports.isPointInRect = isPointInRect;
  exports.isRgbArray = isRgbArray;
  exports.isRgbStr = isRgbStr;
  exports.isRgbaArray = isRgbaArray;
  exports.isRgbaStr = isRgbaStr;
  exports.isString = isString;
  exports.isUint8 = isUint8;
  exports.isUint8Array = isUint8Array;
  exports.iteratorToArray = iteratorToArray;
  exports.l1Dist = l1Dist;
  exports.l1DistByDim = l1DistByDim;
  exports.l1PointDist = l1PointDist;
  exports.l2Dist = l2Dist;
  exports.l2DistByDim = l2DistByDim;
  exports.l2Norm = l2Norm;
  exports.l2PointDist = l2PointDist;
  exports.lDist = lDist;
  exports.lPointDist = lPointDist;
  exports.lRectDist = lRectDist;
  exports.linear = linear;
  exports.map = map;
  exports.mapFilter = mapFilter;
  exports.max = max;
  exports.maxNan = maxNan;
  exports.maxVector = maxVector;
  exports.mean = mean;
  exports.meanNan = meanNan;
  exports.meanVector = meanVector;
  exports.median = median;
  exports.medianVector = medianVector;
  exports.mergeMaps = mergeMaps;
  exports.min = min;
  exports.minNan = minNan;
  exports.minVector = minVector;
  exports.mod = mod;
  exports.nextAnimationFrame = nextAnimationFrame;
  exports.noop = noop;
  exports.normalize = normalize;
  exports.nthIndexOf = nthIndexOf;
  exports.pipe = pipe;
  exports.quadIn = quadIn;
  exports.quadInOut = quadInOut;
  exports.quadOut = quadOut;
  exports.quartIn = quartIn;
  exports.quartInOut = quartInOut;
  exports.quartOut = quartOut;
  exports.quintIn = quintIn;
  exports.quintInOut = quintInOut;
  exports.quintOut = quintOut;
  exports.randomString = randomString;
  exports.range = range;
  exports.rangeMap = rangeMap;
  exports.removeAllChildren = removeAllChildren;
  exports.removeClass = removeClass;
  exports.removeLastChild = removeLastChild;
  exports.rgbStrToDec = rgbStrToDec;
  exports.rgbStrToRgbArray = rgbStrToRgbArray;
  exports.rgbToHex = rgbToHex;
  exports.rgbaStrToRgbaArray = rgbaStrToRgbaArray;
  exports.some = some;
  exports.sortAsc = sortAsc;
  exports.sortDesc = sortDesc;
  exports.sortPos = sortPos;
  exports.sum = sum;
  exports.sumNan = sumNan;
  exports.sumVector = sumVector;
  exports.throttle = throttle;
  exports.throttleAndDebounce = throttleAndDebounce;
  exports.timeout = timeout;
  exports.toRgbaArray = toRgbaArray;
  exports.toVoid = toVoid;
  exports.unionIntegers = unionIntegers;
  exports.unique = unique;
  exports.update = update;
  exports.version = version;
  exports.wait = wait;
  exports.withConstructor = withConstructor;
  exports.withForwardedMethod = withForwardedMethod;
  exports.withProperty = withProperty;
  exports.withReadOnlyProperty = withReadOnlyProperty;
  exports.withStaticProperty = withStaticProperty;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
