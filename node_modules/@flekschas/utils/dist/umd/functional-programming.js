// @flekschas/utils v0.29.0 Copyright 2021 Fritz Lekschas
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/defineEnumerableProperties'), require('@babel/runtime/helpers/defineProperty'), require('@babel/runtime/helpers/typeof')) :
  typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/defineEnumerableProperties', '@babel/runtime/helpers/defineProperty', '@babel/runtime/helpers/typeof'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.utils = global.utils || {}, global._defineEnumerableProperties, global._defineProperty));
}(this, (function (exports, _defineEnumerableProperties, _defineProperty) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var _defineEnumerableProperties__default = /*#__PURE__*/_interopDefaultLegacy(_defineEnumerableProperties);
  var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

  /**
   * Restrict value to be within [min, max]
   * @description About 18% faster than `Math.max(min, Math.min(max, value))`
   * @param {Number} value - Value to be clamped
   * @param {Number} min - Min value
   * @param {Number} max - Max value
   * @return {Number} Clamped value
   */
  /**
   * Identity function
   * @param   {*}  x  Any kind of value
   * @return  {*}  `x`
   */

  var identity = function identity(x) {
    return x;
  };

  var assign = function assign(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
      // eslint-disable-next-line no-shadow
      var descriptors = Object.keys(source).reduce(function (descriptors, key) {
        descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
        return descriptors;
      }, {}); // By default, Object.assign copies enumerable Symbols, too

      Object.getOwnPropertySymbols(source).forEach(function (symbol) {
        var descriptor = Object.getOwnPropertyDescriptor(source, symbol);

        if (descriptor.enumerable) {
          descriptors[symbol] = descriptor;
        }
      });
      Object.defineProperties(target, descriptors);
    });
    return target;
  };

  var capitalize = function capitalize(str) {
    return "".concat(str[0].toUpperCase()).concat(str.substr(1));
  };

  /**
   * Functional version of `Array.map()`
   *
   * @description
   * The pure map function is more powerful because it can be used on data types
   * other than Array too.
   *
   * @param {function} f - Mapping function
   * @return {array} Mapped array
   */

  var map = function map(f) {
    return function (x) {
      return Array.prototype.map.call(x, f);
    };
  };
  /**
   * Map and filter data in one iteration.
   *
   * Combining the loops is about 7-8x faster than
   *
   * @param   {function}  mapFn  Mapping function
   * @param   {function}  filterFn  Filter function
   * @return  {function}  A function that accepts a single array paremeter
   */

  var mapFilter = function mapFilter(mapFn, filterFn) {
    return (
      /**
       * @param   {array}  arr  An array to be mapped and filtered
       * @returns {array}  The mapped and filtered array
       */
      function (arr) {
        var out = []; // loop though array

        for (var i = 0; i < arr.length; i++) {
          var result = mapFn(arr[i], i);
          if (filterFn(result, out.length)) out.push(result);
        }

        return out;
      }
    );
  };
  /**
   * Functional version of `Array.forEach`
   *
   * @description
   * More flexible and applicable to other array-like data types.
   *
   * @param {function} f - Modifier function applied on every item of the array.
   * @return {array} Modified array-like variable.
   */

  var forEach = function forEach(f) {
    return function (x) {
      return Array.prototype.forEach.call(x, f);
    };
  };
  /**
   * Convenience function to compose functions
   * @param {...function} fns - Array of functions
   * @return {function} The composed function
   */

  var pipe = function pipe() {
    for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
      fns[_key] = arguments[_key];
    }

    return (
      /**
       * @param {*} x - Some value
       * @return {*} Output of the composed function
       */
      function (x) {
        return fns.reduce(function (y, f) {
          return f(y);
        }, x);
      }
    );
  };
  /**
   * Functional version of `Array.forEach`. More flexible and applicable to
   *   other array-like data types like `NodeList`.
   * @param   {function}  f  Modifier function applied on every item of the
   *   array.
   * @return  {*}  Modified array-like variable.
   */

  var some = function some(f) {
    return function (x) {
      return Array.prototype.some.call(x, f);
    };
  };
  /**
   * Assign a constructor to the object
   * @param {function} constructor - Constructor functions
   */

  var withConstructor = function withConstructor(constructor) {
    return function (self) {
      return assign({
        __proto__: {
          constructor: constructor
        }
      }, self);
    };
  };
  /**
   * Forward a method call
   * @param {string} name - Exposed function name
   * @param {function} fn - Function to be forwarded
   */

  var withForwardedMethod = function withForwardedMethod(name, fn) {
    return function (self) {
      return assign(self, _defineProperty__default['default']({}, name, function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return fn.apply(this, args);
      }));
    };
  };
  /**
   * Assign a property to an object
   * @param {string} name - Name of the property
   * @param {object} options - Option object
   * @param {*} options.initialValue - Initial value of the property
   * @param {function} options.getter - Custom getter
   * @param {function} options.setter - Custom setter
   * @param {function} options.cloner - Clone function. Used before the value
   *   is returned.
   * @param {function} options.transformer - Value transformer. Used before a new
   *   value is set.
   * @param {function} options.validator - Validator function decides whether the
   *   new and transformed value is set or not.
   */

  var withProperty = function withProperty(name) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$initialValue = _ref.initialValue,
        initialValue = _ref$initialValue === void 0 ? undefined : _ref$initialValue,
        customGetter = _ref.getter,
        customSetter = _ref.setter,
        _ref$cloner = _ref.cloner,
        cloner = _ref$cloner === void 0 ? identity : _ref$cloner,
        _ref$transformer = _ref.transformer,
        transformer = _ref$transformer === void 0 ? identity : _ref$transformer,
        _ref$validator = _ref.validator,
        validator = _ref$validator === void 0 ? function () {
      return true;
    } : _ref$validator;

    return function (self) {
      var _assign2, _mutatorMap;

      var value = initialValue;
      var getter = customGetter ? function () {
        return customGetter();
      } : function () {
        return cloner(value);
      };
      var setter = customSetter ? function (newValue) {
        return customSetter(newValue);
      } : function (newValue) {
        var transformedNewValue = transformer(newValue);
        value = validator(transformedNewValue) ? transformedNewValue : value;
      };
      return assign(self, (_assign2 = {}, _mutatorMap = {}, _mutatorMap[name] = _mutatorMap[name] || {}, _mutatorMap[name].get = function () {
        return getter();
      }, _defineProperty__default['default'](_assign2, "set".concat(capitalize(name)), function set(newValue) {
        setter(newValue);
      }), _defineEnumerableProperties__default['default'](_assign2, _mutatorMap), _assign2));
    };
  };
  /**
   * Assign a read-only property to an object
   * @param {string} name - Name of the property
   * @param {function} getter - Getter function
   */

  var withReadOnlyProperty = function withReadOnlyProperty(name, getter) {
    return function (self) {
      var _assign3, _mutatorMap2;

      return assign(self, (_assign3 = {}, _mutatorMap2 = {}, _mutatorMap2[name] = _mutatorMap2[name] || {}, _mutatorMap2[name].get = function () {
        return getter();
      }, _defineEnumerableProperties__default['default'](_assign3, _mutatorMap2), _assign3));
    };
  };
  /**
   * Assign a static property to an object
   * @param {string} name - Name of the property
   * @param {*} value - Static value
   */

  var withStaticProperty = function withStaticProperty(name, value) {
    return function (self) {
      var _assign4, _mutatorMap3;

      return assign(self, (_assign4 = {}, _mutatorMap3 = {}, _mutatorMap3[name] = _mutatorMap3[name] || {}, _mutatorMap3[name].get = function () {
        return value;
      }, _defineEnumerableProperties__default['default'](_assign4, _mutatorMap3), _assign4));
    };
  };

  exports.forEach = forEach;
  exports.map = map;
  exports.mapFilter = mapFilter;
  exports.pipe = pipe;
  exports.some = some;
  exports.withConstructor = withConstructor;
  exports.withForwardedMethod = withForwardedMethod;
  exports.withProperty = withProperty;
  exports.withReadOnlyProperty = withReadOnlyProperty;
  exports.withStaticProperty = withStaticProperty;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
