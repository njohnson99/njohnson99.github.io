// @flekschas/utils v0.29.0 Copyright 2021 Fritz Lekschas
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/typeof')) :
  typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/typeof'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.utils = global.utils || {}, global._typeof));
}(this, (function (exports, _typeof) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);

  var assign = function assign(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (source) {
      // eslint-disable-next-line no-shadow
      var descriptors = Object.keys(source).reduce(function (descriptors, key) {
        descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
        return descriptors;
      }, {}); // By default, Object.assign copies enumerable Symbols, too

      Object.getOwnPropertySymbols(source).forEach(function (symbol) {
        var descriptor = Object.getOwnPropertyDescriptor(source, symbol);

        if (descriptor.enumerable) {
          descriptors[symbol] = descriptor;
        }
      });
      Object.defineProperties(target, descriptors);
    });
    return target;
  };
  /**
   * Deep clone an object.
   *
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object.
   */

  var deepClone = function deepClone(source) {
    var target;
    return extend(target, source);
  };
  /**
   * Extend an object with another object.
   *
   * @param {object} target - Target object or `undefined` if a new object should
   *   be created.
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object
   */

  var extend = function extend(target, source) {
    if (source === null || _typeof__default['default'](source) !== 'object') {
      return source;
    }

    if (source.constructor !== Object && source.constructor !== Array) {
      return source;
    }

    if (source.constructor === Date || source.constructor === RegExp || source.constructor === Function || source.constructor === String || source.constructor === Number || source.constructor === Boolean) {
      return new source.constructor(source);
    }

    var out = target || new source.constructor();
    Object.keys(source).forEach(function (key) {
      var descriptor = Object.getOwnPropertyDescriptor(source, key);

      if (typeof out[key] === 'undefined') {
        if (typeof descriptor.value === 'undefined') {
          Object.defineProperty(out, key, descriptor);
        } else {
          out[key] = extend(undefined, source[key]);
        }
      }
    });
    return out;
  };
  /**
   * Update the target object by the source object. Besides extending that target
   * object, properties that are not present in the source object.
   *
   * @param {object} target - Target object or `undefined` if a new object should
   *   be created.
   * @param {object} source - Object to be cloned.
   * @return {object} Cloned `source` object
   */

  var update = function update(target, source) {
    // Return boolean, number, strings, and null
    if (source === null || _typeof__default['default'](source) !== 'object') {
      return source;
    } // Recreate special objects. Special objects are of type "object" but are not
    // simple arrays or objects, e.g.:
    // Date, RegExp, String, Number, Boolean, or Function


    if (source.constructor !== Object && source.constructor !== Array) {
      return new source.constructor(source);
    }

    var out = new target.constructor(); // Update properties

    var updated = false;
    Object.keys(source).forEach(function (key) {
      var descriptor = Object.getOwnPropertyDescriptor(source, key);

      if (target[key] === undefined) {
        // The `key` prop does not exist on `target` so we will extend `target`
        // with the `key` prop.
        if (typeof descriptor.value === 'undefined') {
          Object.defineProperty(out, key, descriptor);
        } else {
          out[key] = extend(undefined, source[key]);
        }
      } else {
        // The `key` prop exist on `target` so we update it.
        out[key] = update(target[key], source[key]);
      }

      updated = updated || out[key] !== target[key];
    }); // In case no property was updated but some were removed `updated` needs to be
    // true

    updated = updated || Object.keys(target).filter(function (key) {
      return typeof source[key] === 'undefined';
    }).length;
    return updated ? out : target;
  };

  exports.assign = assign;
  exports.deepClone = deepClone;
  exports.extend = extend;
  exports.update = update;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
